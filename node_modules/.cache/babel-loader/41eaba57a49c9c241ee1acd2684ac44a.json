{"ast":null,"code":"import invariant from \"invariant\"; ////////////////////////////////////////////////////////////////////////////////\n// startsWith(string, search) - Check if `string` starts with `search`\n\nvar startsWith = function startsWith(string, search) {\n  return string.substr(0, search.length) === search;\n}; ////////////////////////////////////////////////////////////////////////////////\n// pick(routes, uri)\n//\n// Ranks and picks the best route to match. Each segment gets the highest\n// amount of points, then the type of segment gets an additional amount of\n// points where\n//\n//     static > dynamic > splat > root\n//\n// This way we don't have to worry about the order of our routes, let the\n// computers do it.\n//\n// A route looks like this\n//\n//     { path, default, value }\n//\n// And a returned match looks like:\n//\n//     { route, params, uri }\n//\n// I know, I should use TypeScript not comments for these types.\n\n\nvar pick = function pick(routes, uri) {\n  var match = void 0;\n  var default_ = void 0;\n\n  var _uri$split = uri.split(\"?\"),\n      uriPathname = _uri$split[0];\n\n  var uriSegments = segmentize(uriPathname);\n  var isRootUri = uriSegments[0] === \"\";\n  var ranked = rankRoutes(routes);\n\n  for (var i = 0, l = ranked.length; i < l; i++) {\n    var missed = false;\n    var route = ranked[i].route;\n\n    if (route.default) {\n      default_ = {\n        route: route,\n        params: {},\n        uri: uri\n      };\n      continue;\n    }\n\n    var routeSegments = segmentize(route.path);\n    var params = {};\n    var max = Math.max(uriSegments.length, routeSegments.length);\n    var index = 0;\n\n    for (; index < max; index++) {\n      var routeSegment = routeSegments[index];\n      var uriSegment = uriSegments[index];\n\n      if (isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/*\n        var param = routeSegment.slice(1) || \"*\";\n        params[param] = uriSegments.slice(index).map(decodeURIComponent).join(\"/\");\n        break;\n      }\n\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true;\n        break;\n      }\n\n      var dynamicMatch = paramRe.exec(routeSegment);\n\n      if (dynamicMatch && !isRootUri) {\n        var matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1;\n        !matchIsNotReserved ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"<Router> dynamic segment \\\"\" + dynamicMatch[1] + \"\\\" is a reserved name. Please use a different name in path \\\"\" + route.path + \"\\\".\") : invariant(false) : void 0;\n        var value = decodeURIComponent(uriSegment);\n        params[dynamicMatch[1]] = value;\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true;\n        break;\n      }\n    }\n\n    if (!missed) {\n      match = {\n        route: route,\n        params: params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\")\n      };\n      break;\n    }\n  }\n\n  return match || default_ || null;\n}; ////////////////////////////////////////////////////////////////////////////////\n// match(path, uri) - Matches just one path to a uri, also lol\n\n\nvar match = function match(path, uri) {\n  return pick([{\n    path: path\n  }], uri);\n}; ////////////////////////////////////////////////////////////////////////////////\n// resolve(to, basepath)\n//\n// Resolves URIs as though every path is a directory, no files.  Relative URIs\n// in the browser can feel awkward because not only can you be \"in a directory\"\n// you can be \"at a file\", too. For example\n//\n//     browserSpecResolve('foo', '/bar/') => /bar/foo\n//     browserSpecResolve('foo', '/bar') => /foo\n//\n// But on the command line of a file system, it's not as complicated, you can't\n// `cd` from a file, only directories.  This way, links have to know less about\n// their current path. To go deeper you can do this:\n//\n//     <Link to=\"deeper\"/>\n//     // instead of\n//     <Link to=`{${props.uri}/deeper}`/>\n//\n// Just like `cd`, if you want to go deeper from the command line, you do this:\n//\n//     cd deeper\n//     # not\n//     cd $(pwd)/deeper\n//\n// By treating every path as a directory, linking to relative paths should\n// require less contextual information and (fingers crossed) be more intuitive.\n\n\nvar resolve = function resolve(to, base) {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to;\n  }\n\n  var _to$split = to.split(\"?\"),\n      toPathname = _to$split[0],\n      toQuery = _to$split[1];\n\n  var _base$split = base.split(\"?\"),\n      basePathname = _base$split[0];\n\n  var toSegments = segmentize(toPathname);\n  var baseSegments = segmentize(basePathname); // ?a=b, /users?b=c => /users?a=b\n\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery);\n  } // profile, /users/789 => /users/789/profile\n\n\n  if (!startsWith(toSegments[0], \".\")) {\n    var pathname = baseSegments.concat(toSegments).join(\"/\");\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\n  } // ./         /users/123  =>  /users/123\n  // ../        /users/123  =>  /users\n  // ../..      /users/123  =>  /\n  // ../../one  /a/b/c/d    =>  /a/b/one\n  // .././one   /a/b/c/d    =>  /a/b/c/one\n\n\n  var allSegments = baseSegments.concat(toSegments);\n  var segments = [];\n\n  for (var i = 0, l = allSegments.length; i < l; i++) {\n    var segment = allSegments[i];\n    if (segment === \"..\") segments.pop();else if (segment !== \".\") segments.push(segment);\n  }\n\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery);\n}; ////////////////////////////////////////////////////////////////////////////////\n// insertParams(path, params)\n\n\nvar insertParams = function insertParams(path, params) {\n  var segments = segmentize(path);\n  return \"/\" + segments.map(function (segment) {\n    var match = paramRe.exec(segment);\n    return match ? params[match[1]] : segment;\n  }).join(\"/\");\n};\n\nvar validateRedirect = function validateRedirect(from, to) {\n  var filter = function filter(segment) {\n    return isDynamic(segment);\n  };\n\n  var fromString = segmentize(from).filter(filter).sort().join(\"/\");\n  var toString = segmentize(to).filter(filter).sort().join(\"/\");\n  return fromString === toString;\n}; ////////////////////////////////////////////////////////////////////////////////\n// Junk\n\n\nvar paramRe = /^:(.+)/;\nvar SEGMENT_POINTS = 4;\nvar STATIC_POINTS = 3;\nvar DYNAMIC_POINTS = 2;\nvar SPLAT_PENALTY = 1;\nvar ROOT_POINTS = 1;\n\nvar isRootSegment = function isRootSegment(segment) {\n  return segment === \"\";\n};\n\nvar isDynamic = function isDynamic(segment) {\n  return paramRe.test(segment);\n};\n\nvar isSplat = function isSplat(segment) {\n  return segment && segment[0] === \"*\";\n};\n\nvar rankRoute = function rankRoute(route, index) {\n  var score = route.default ? 0 : segmentize(route.path).reduce(function (score, segment) {\n    score += SEGMENT_POINTS;\n    if (isRootSegment(segment)) score += ROOT_POINTS;else if (isDynamic(segment)) score += DYNAMIC_POINTS;else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY;else score += STATIC_POINTS;\n    return score;\n  }, 0);\n  return {\n    route: route,\n    score: score,\n    index: index\n  };\n};\n\nvar rankRoutes = function rankRoutes(routes) {\n  return routes.map(rankRoute).sort(function (a, b) {\n    return a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index;\n  });\n};\n\nvar segmentize = function segmentize(uri) {\n  return uri // strip starting/ending slashes\n  .replace(/(^\\/+|\\/+$)/g, \"\").split(\"/\");\n};\n\nvar addQuery = function addQuery(pathname, query) {\n  return pathname + (query ? \"?\" + query : \"\");\n};\n\nvar reservedNames = [\"uri\", \"path\"];\n/**\r\n * Shallow compares two objects.\r\n * @param {Object} obj1 The first object to compare.\r\n * @param {Object} obj2 The second object to compare.\r\n */\n\nvar shallowCompare = function shallowCompare(obj1, obj2) {\n  var obj1Keys = Object.keys(obj1);\n  return obj1Keys.length === Object.keys(obj2).length && obj1Keys.every(function (key) {\n    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];\n  });\n}; ////////////////////////////////////////////////////////////////////////////////\n\n\nexport { startsWith, pick, match, resolve, insertParams, validateRedirect, shallowCompare };","map":{"version":3,"sources":["C:/Users/ranjith_biswas/Desktop/CL_tasks/cl_task/cl_task/node_modules/@reach/router/es/lib/utils.js"],"names":["invariant","startsWith","string","search","substr","length","pick","routes","uri","match","default_","_uri$split","split","uriPathname","uriSegments","segmentize","isRootUri","ranked","rankRoutes","i","l","missed","route","default","params","routeSegments","path","max","Math","index","routeSegment","uriSegment","isSplat","param","slice","map","decodeURIComponent","join","undefined","dynamicMatch","paramRe","exec","matchIsNotReserved","reservedNames","indexOf","process","env","NODE_ENV","value","resolve","to","base","_to$split","toPathname","toQuery","_base$split","basePathname","toSegments","baseSegments","addQuery","pathname","concat","allSegments","segments","segment","pop","push","insertParams","validateRedirect","from","filter","isDynamic","fromString","sort","toString","SEGMENT_POINTS","STATIC_POINTS","DYNAMIC_POINTS","SPLAT_PENALTY","ROOT_POINTS","isRootSegment","test","rankRoute","score","reduce","a","b","replace","query","shallowCompare","obj1","obj2","obj1Keys","Object","keys","every","key","hasOwnProperty"],"mappings":"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","sourcesContent":["import invariant from \"invariant\";\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// startsWith(string, search) - Check if `string` starts with `search`\r\nvar startsWith = function startsWith(string, search) {\r\n  return string.substr(0, search.length) === search;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// pick(routes, uri)\r\n//\r\n// Ranks and picks the best route to match. Each segment gets the highest\r\n// amount of points, then the type of segment gets an additional amount of\r\n// points where\r\n//\r\n//     static > dynamic > splat > root\r\n//\r\n// This way we don't have to worry about the order of our routes, let the\r\n// computers do it.\r\n//\r\n// A route looks like this\r\n//\r\n//     { path, default, value }\r\n//\r\n// And a returned match looks like:\r\n//\r\n//     { route, params, uri }\r\n//\r\n// I know, I should use TypeScript not comments for these types.\r\nvar pick = function pick(routes, uri) {\r\n  var match = void 0;\r\n  var default_ = void 0;\r\n\r\n  var _uri$split = uri.split(\"?\"),\r\n      uriPathname = _uri$split[0];\r\n\r\n  var uriSegments = segmentize(uriPathname);\r\n  var isRootUri = uriSegments[0] === \"\";\r\n  var ranked = rankRoutes(routes);\r\n\r\n  for (var i = 0, l = ranked.length; i < l; i++) {\r\n    var missed = false;\r\n    var route = ranked[i].route;\r\n\r\n    if (route.default) {\r\n      default_ = {\r\n        route: route,\r\n        params: {},\r\n        uri: uri\r\n      };\r\n      continue;\r\n    }\r\n\r\n    var routeSegments = segmentize(route.path);\r\n    var params = {};\r\n    var max = Math.max(uriSegments.length, routeSegments.length);\r\n    var index = 0;\r\n\r\n    for (; index < max; index++) {\r\n      var routeSegment = routeSegments[index];\r\n      var uriSegment = uriSegments[index];\r\n\r\n      if (isSplat(routeSegment)) {\r\n        // Hit a splat, just grab the rest, and return a match\r\n        // uri:   /files/documents/work\r\n        // route: /files/*\r\n        var param = routeSegment.slice(1) || \"*\";\r\n        params[param] = uriSegments.slice(index).map(decodeURIComponent).join(\"/\");\r\n        break;\r\n      }\r\n\r\n      if (uriSegment === undefined) {\r\n        // URI is shorter than the route, no match\r\n        // uri:   /users\r\n        // route: /users/:userId\r\n        missed = true;\r\n        break;\r\n      }\r\n\r\n      var dynamicMatch = paramRe.exec(routeSegment);\r\n\r\n      if (dynamicMatch && !isRootUri) {\r\n        var matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1;\r\n        !matchIsNotReserved ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"<Router> dynamic segment \\\"\" + dynamicMatch[1] + \"\\\" is a reserved name. Please use a different name in path \\\"\" + route.path + \"\\\".\") : invariant(false) : void 0;\r\n        var value = decodeURIComponent(uriSegment);\r\n        params[dynamicMatch[1]] = value;\r\n      } else if (routeSegment !== uriSegment) {\r\n        // Current segments don't match, not dynamic, not splat, so no match\r\n        // uri:   /users/123/settings\r\n        // route: /users/:id/profile\r\n        missed = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!missed) {\r\n      match = {\r\n        route: route,\r\n        params: params,\r\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\")\r\n      };\r\n      break;\r\n    }\r\n  }\r\n\r\n  return match || default_ || null;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// match(path, uri) - Matches just one path to a uri, also lol\r\nvar match = function match(path, uri) {\r\n  return pick([{ path: path }], uri);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// resolve(to, basepath)\r\n//\r\n// Resolves URIs as though every path is a directory, no files.  Relative URIs\r\n// in the browser can feel awkward because not only can you be \"in a directory\"\r\n// you can be \"at a file\", too. For example\r\n//\r\n//     browserSpecResolve('foo', '/bar/') => /bar/foo\r\n//     browserSpecResolve('foo', '/bar') => /foo\r\n//\r\n// But on the command line of a file system, it's not as complicated, you can't\r\n// `cd` from a file, only directories.  This way, links have to know less about\r\n// their current path. To go deeper you can do this:\r\n//\r\n//     <Link to=\"deeper\"/>\r\n//     // instead of\r\n//     <Link to=`{${props.uri}/deeper}`/>\r\n//\r\n// Just like `cd`, if you want to go deeper from the command line, you do this:\r\n//\r\n//     cd deeper\r\n//     # not\r\n//     cd $(pwd)/deeper\r\n//\r\n// By treating every path as a directory, linking to relative paths should\r\n// require less contextual information and (fingers crossed) be more intuitive.\r\nvar resolve = function resolve(to, base) {\r\n  // /foo/bar, /baz/qux => /foo/bar\r\n  if (startsWith(to, \"/\")) {\r\n    return to;\r\n  }\r\n\r\n  var _to$split = to.split(\"?\"),\r\n      toPathname = _to$split[0],\r\n      toQuery = _to$split[1];\r\n\r\n  var _base$split = base.split(\"?\"),\r\n      basePathname = _base$split[0];\r\n\r\n  var toSegments = segmentize(toPathname);\r\n  var baseSegments = segmentize(basePathname);\r\n\r\n  // ?a=b, /users?b=c => /users?a=b\r\n  if (toSegments[0] === \"\") {\r\n    return addQuery(basePathname, toQuery);\r\n  }\r\n\r\n  // profile, /users/789 => /users/789/profile\r\n  if (!startsWith(toSegments[0], \".\")) {\r\n    var pathname = baseSegments.concat(toSegments).join(\"/\");\r\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\r\n  }\r\n\r\n  // ./         /users/123  =>  /users/123\r\n  // ../        /users/123  =>  /users\r\n  // ../..      /users/123  =>  /\r\n  // ../../one  /a/b/c/d    =>  /a/b/one\r\n  // .././one   /a/b/c/d    =>  /a/b/c/one\r\n  var allSegments = baseSegments.concat(toSegments);\r\n  var segments = [];\r\n  for (var i = 0, l = allSegments.length; i < l; i++) {\r\n    var segment = allSegments[i];\r\n    if (segment === \"..\") segments.pop();else if (segment !== \".\") segments.push(segment);\r\n  }\r\n\r\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// insertParams(path, params)\r\nvar insertParams = function insertParams(path, params) {\r\n  var segments = segmentize(path);\r\n  return \"/\" + segments.map(function (segment) {\r\n    var match = paramRe.exec(segment);\r\n    return match ? params[match[1]] : segment;\r\n  }).join(\"/\");\r\n};\r\n\r\nvar validateRedirect = function validateRedirect(from, to) {\r\n  var filter = function filter(segment) {\r\n    return isDynamic(segment);\r\n  };\r\n  var fromString = segmentize(from).filter(filter).sort().join(\"/\");\r\n  var toString = segmentize(to).filter(filter).sort().join(\"/\");\r\n  return fromString === toString;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Junk\r\nvar paramRe = /^:(.+)/;\r\n\r\nvar SEGMENT_POINTS = 4;\r\nvar STATIC_POINTS = 3;\r\nvar DYNAMIC_POINTS = 2;\r\nvar SPLAT_PENALTY = 1;\r\nvar ROOT_POINTS = 1;\r\n\r\nvar isRootSegment = function isRootSegment(segment) {\r\n  return segment === \"\";\r\n};\r\nvar isDynamic = function isDynamic(segment) {\r\n  return paramRe.test(segment);\r\n};\r\nvar isSplat = function isSplat(segment) {\r\n  return segment && segment[0] === \"*\";\r\n};\r\n\r\nvar rankRoute = function rankRoute(route, index) {\r\n  var score = route.default ? 0 : segmentize(route.path).reduce(function (score, segment) {\r\n    score += SEGMENT_POINTS;\r\n    if (isRootSegment(segment)) score += ROOT_POINTS;else if (isDynamic(segment)) score += DYNAMIC_POINTS;else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY;else score += STATIC_POINTS;\r\n    return score;\r\n  }, 0);\r\n  return { route: route, score: score, index: index };\r\n};\r\n\r\nvar rankRoutes = function rankRoutes(routes) {\r\n  return routes.map(rankRoute).sort(function (a, b) {\r\n    return a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index;\r\n  });\r\n};\r\n\r\nvar segmentize = function segmentize(uri) {\r\n  return uri\r\n  // strip starting/ending slashes\r\n  .replace(/(^\\/+|\\/+$)/g, \"\").split(\"/\");\r\n};\r\n\r\nvar addQuery = function addQuery(pathname, query) {\r\n  return pathname + (query ? \"?\" + query : \"\");\r\n};\r\n\r\nvar reservedNames = [\"uri\", \"path\"];\r\n\r\n/**\r\n * Shallow compares two objects.\r\n * @param {Object} obj1 The first object to compare.\r\n * @param {Object} obj2 The second object to compare.\r\n */\r\nvar shallowCompare = function shallowCompare(obj1, obj2) {\r\n  var obj1Keys = Object.keys(obj1);\r\n  return obj1Keys.length === Object.keys(obj2).length && obj1Keys.every(function (key) {\r\n    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];\r\n  });\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\nexport { startsWith, pick, match, resolve, insertParams, validateRedirect, shallowCompare };"]},"metadata":{},"sourceType":"module"}